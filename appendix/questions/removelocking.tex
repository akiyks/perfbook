% appendix/questions/removelocking.tex
% mainfile: ../../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\section{Why Not Remove Locking?}
\label{sec:app:questions:Why Not Remove Locking?}

There can be no doubt that many have cast locking as the evil villain
of parallel programming, and not entirely without reason.
And there are important examples where lockless code does much better
than its locked counterpart, a few of which are discussed in
\cref{sec:advsync:Non-Blocking Synchronization}.

However, lockless algorithms are not guaranteed to perform and scale
well, as shown by
\cref{fig:count:Atomic Increment Scalability on x86} on
page~\pageref{fig:count:Atomic Increment Scalability on x86}.
Furthermore, as a general rule, the more complex the algorithm,
the greater the advantage of combining locking with selected
lockless techniques, even with significant hardware support,
as shown in
\IfEbookSize{
\cref{tab:future:Comparison of Locking and HTM,%
tab:future:Comparison of Locking (Augmented by RCU or Hazard Pointers) and HTM}
on
\cpageref{tab:future:Comparison of Locking and HTM,%
tab:future:Comparison of Locking (Augmented by RCU or Hazard Pointers) and HTM}.
}{
\cref{tab:future:Comparison of Locking (Plain and Augmented) and HTM}
on
\cpageref{tab:future:Comparison of Locking (Plain and Augmented) and HTM}.
}
\Cref{sec:advsync:Non-Blocking Synchronization}
looks more deeply at non-blocking synchronization, which is a popular
lockless methodology.

As a more general rule, a sound-bite approach to parallel programming
is not likely to end well.
Some would argue that this is also true of many other fields of endeavor.
