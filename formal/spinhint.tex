% formal/spinhint.html
% mainfile: ../perfbook.tex
% SPDX-License-Identifier: CC-BY-SA-3.0

\section{State-Space Search}
\label{sec:formal:State-Space Search}
%
\epigraph{Follow every byway / Every path you know.}
	 {\emph{``Climb Every Mountain'', Rodgers \& Hammerstein}}

This section features the general-purpose Promela and Spin tools,
which may be used to carry out a full
state-space search of many types of multi-threaded code.
They are also quite useful for verifying data communication protocols.
Section~\ref{sec:formal:Promela and Spin}
introduces Promela and Spin, including a couple of warm-up exercises
verifying both non-atomic and atomic increment.
Section~\ref{sec:formal:How to Use Promela}
describes use of Promela, including example command lines and a
comparison of Promela syntax to that of C.
Section~\ref{sec:formal:Promela Example: Locking}
shows how Promela may be used to verify locking,
\ref{sec:formal:Promela Example: QRCU}
uses Promela to verify an unusual implementation of RCU named ``QRCU'',
and finally
Section~\ref{sec:formal:Promela Parable: dynticks and Preemptible RCU}
applies Promela to RCU's dyntick-idle implementation.

\subsection{Promela and Spin}
\label{sec:formal:Promela and Spin}

Promela is a language designed to help verify protocols, but which
can also be used to verify small parallel algorithms.
You recode your algorithm and correctness constraints in the C-like
language Promela, and then use Spin to translate it into a C program
that you can compile and run.
The resulting program conducts a full state-space search of your
algorithm, either verifying or finding counter-examples for
assertions that you can include in your Promela program.

This full-state search can be extremely powerful, but can also be a two-edged
sword.
If your algorithm is too complex or your Promela implementation is
careless, there might be more states than fit in memory.
Furthermore, even given sufficient memory, the state-space search might
well run for longer than the expected lifetime of the universe.
Therefore, use this tool for compact but complex parallel algorithms.
Attempts to naively apply it to even moderate-scale algorithms (let alone
the full Linux kernel) will end badly.

Promela and Spin may be downloaded from
\url{http://spinroot.com/spin/whatispin.html}.

The above site also gives links to Gerard Holzmann's excellent
book~\cite{Holzmann03a} on Promela and Spin,
as well as searchable online references starting at:
\url{http://www.spinroot.com/spin/Man/index.html}.

The remainder of this section describes how to use Promela to debug
parallel algorithms, starting with simple examples and progressing to
more complex uses.

\subsubsection{Promela Warm-Up: Non-Atomic Increment}
\label{sec:formal:Promela Warm-Up: Non-Atomic Increment}
\NoIndentAfterThis

\begin{listing}[tbp]
\input{CodeSamples/formal/promela/increment@whole.fcv}
\caption{Promela Code for Non-Atomic Increment}
\label{lst:formal:Promela Code for Non-Atomic Increment}
\end{listing}

\begin{lineref}[ln:formal:promela:increment:whole]
Listing~\ref{lst:formal:Promela Code for Non-Atomic Increment}
demonstrates the textbook race condition
resulting from non-atomic increment.
Line~\lnref{nprocs} defines the number of processes to run (we will vary this
to see the effect on state space), line~\lnref{count} defines the counter,
and line~\lnref{prog} is used to implement the assertion that appears on
lines~\lnref{assert:b}-\lnref{assert:e}.

Lines~\lnref{proc:b}-\lnref{proc:e} define a process that increments
the counter non-atomically.
The argument \co{me} is the process number, set by the initialization
block later in the code.
Because simple Promela statements are each assumed atomic, we must
break the increment into the two statements on
lines~\lnref{incr:b}-\lnref{incr:e}.
The assignment on line~\lnref{setprog} marks the process's completion.
Because the Spin system will fully search the state space, including
all possible sequences of states, there is no need for the loop
that would be used for conventional testing.

Lines~\lnref{init:b}-\lnref{init:e} are the initialization block,
which is executed first.
Lines~\lnref{doinit:b}-\lnref{doinit:e} actually do the initialization,
while lines~\lnref{assert:b}-\lnref{assert:e}
perform the assertion.
Both are atomic blocks in order to avoid unnecessarily increasing
the state space: because they are not part of the algorithm proper,
we lose no verification coverage by making them atomic.

The \co{do-od} construct on lines~\lnref{dood1:b}-\lnref{dood1:e}
implements a Promela loop,
which can be thought of as a C \co{for (;;)} loop containing a
\co{switch} statement that allows expressions in case labels.
The condition blocks (prefixed by \co{::})
are scanned non-deterministically,
though in this case only one of the conditions can possibly hold at a given
time.
The first block of the \co{do-od} from
lines~\lnref{block1:b}-\lnref{block1:e}
initializes the i-th
incrementer's progress cell, runs the i-th incrementer's process, and
then increments the variable \co{i}.
The second block of the \co{do-od} on
line~\lnref{block2} exits the loop once
these processes have been started.

The atomic block on lines~\lnref{assert:b}-\lnref{assert:e} also contains
a similar \co{do-od}
loop that sums up the progress counters.
The \co{assert()} statement on line~\lnref{assert} verifies that
if all processes
have been completed, then all counts have been correctly recorded.
\end{lineref}

You can build and run this program as follows:

\begin{VerbatimU}
spin -a increment.spin      # Translate the model to C
cc -DSAFETY -o pan pan.c    # Compile the model
./pan                       # Run the model
\end{VerbatimU}

\begin{listing}[tbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/increment.spin.lst}
\vspace*{-9pt}
\caption{Non-Atomic Increment Spin Output}
\label{lst:formal:Non-Atomic Increment Spin Output}
\end{listing}

This will produce output as shown in
Listing~\ref{lst:formal:Non-Atomic Increment Spin Output}.
The first line tells us that our assertion was violated (as expected
given the non-atomic increment!).
The second line that a \co{trail} file was written describing how the
assertion was violated.
The ``Warning'' line reiterates that all was not well with our model.
The second paragraph describes the type of state-search being carried out,
in this case for assertion violations and invalid end states.
The third paragraph gives state-size statistics: this small model had only
45 states.
The final line shows memory usage.

The \co{trail} file may be rendered human-readable as follows:

\begin{VerbatimU}
spin -t -p increment.spin
\end{VerbatimU}

\begin{listing*}[htbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/increment.spin.trail.lst}
\vspace*{-9pt}
\caption{Non-Atomic Increment Error Trail}
\label{lst:formal:Non-Atomic Increment Error Trail}
\end{listing*}

This gives the output shown in
Listing~\ref{lst:formal:Non-Atomic Increment Error Trail}.
As can be seen, the first portion of the init block created both
incrementer processes, both of which first fetched the counter,
then both incremented and stored it, losing a count.
The assertion then triggered, after which the global state is displayed.

\subsubsection{Promela Warm-Up: Atomic Increment}
\label{sec:formal:Promela Warm-Up: Atomic Increment}
\NoIndentAfterThis

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/atomicincrement@incrementer.fcv}
\caption{Promela Code for Atomic Increment}
\label{lst:formal:Promela Code for Atomic Increment}
\end{listing}

\begin{listing}[htbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/atomicincrement.spin.lst}
\vspace*{-9pt}
\caption{Atomic Increment Spin Output}
\label{lst:formal:Atomic Increment Spin Output}
\end{listing}

It is easy to fix this example by placing the body of the incrementer
processes in an atomic blocks as shown in
Listing~\ref{lst:formal:Promela Code for Atomic Increment}.
One could also have simply replaced the pair of statements with
\co{counter = counter + 1}, because Promela statements are
atomic.
Either way, running this modified model gives us an error-free traversal
of the state space, as shown in
Listing~\ref{lst:formal:Atomic Increment Spin Output}.

\begin{table}
\rowcolors{1}{}{lightgray}
\small
\renewcommand*{\arraystretch}{1.2}
\centering
\begin{tabular}{S[table-format = 1.0]S[table-format = 7.0]S[table-format = 3.1]}
	\toprule
	\multicolumn{1}{l}{\# incrementers} &
		\multicolumn{1}{r}{\# states} &
			\multicolumn{1}{r}{total memory usage (MB)} \\
	\midrule
	1 &		        11 &        128.7 \\
	2 &		        52 &        128.7 \\
	3 &		       372 &        128.7 \\
	4 &		     3 496 &        128.9 \\
	5 &		    40 221 &        131.7 \\
	6 &		   545 720 &        174.0 \\
	7 &		 8 521 446 &        881.9 \\
	\bottomrule
\end{tabular}
\caption{Memory Usage of Increment Model}
\label{tab:advsync:Memory Usage of Increment Model}
\end{table}

Table~\ref{tab:advsync:Memory Usage of Increment Model}
shows the number of states and memory consumed
as a function of number of incrementers modeled
(by redefining \co{NUMPROCS}):

Running unnecessarily large models is thus subtly discouraged, although
882\,MB is well within the limits of modern desktop and laptop machines.

With this example under our belt, let's take a closer look at the
commands used to analyze Promela models and then look at more
elaborate examples.

\subsection{How to Use Promela}
\label{sec:formal:How to Use Promela}

Given a source file \path{qrcu.spin}, one can use the following commands:

\begin{description}[style=nextline]
\item	[\tco{spin -a qrcu.spin}]
	Create a file \path{pan.c} that fully searches the state machine.
\item	[\tco{cc -DSAFETY [-DCOLLAPSE] [-DMA=N] -o pan pan.c}]
	Compile the generated state-machine search.  The \co{-DSAFETY}
	generates optimizations that are appropriate if you have only
	assertions (and perhaps \co{never} statements).  If you have
	liveness, fairness, or forward-progress checks, you may need
	to compile without \co{-DSAFETY}.  If you leave off \co{-DSAFETY}
	when you could have used it, the program will let you know.

	The optimizations produced by \co{-DSAFETY} greatly speed things
	up, so you should use it when you can.
	An example situation where you cannot use \co{-DSAFETY} is
	when checking for livelocks (AKA ``non-progress cycles'')
	via \co{-DNP}.

	The optional \co{-DCOLLAPSE} generates code for a state vector
	compression mode.

	Another optional flag \co{-DMA=N} generates code for a slow
	but aggressive state-space memory compression mode.
\item	[\tco{./pan [-mN] [-wN]}]
	This actually searches the state space.  The number of states
	can reach into the tens of millions with very small state
	machines, so you will need a machine with large memory.
	For example, \path{qrcu.spin} with 3~updaters and 2~readers required
	10.5\,GB of memory even with the \co{-DCOLLAPSE} flag.

	If you see a message from \co{./pan} saying:
	``error: max search depth too small'', you need to increase
	the maximum depth by a \co{-mN} option for a complete search.
	The default is \co{-m10000}.

	The \co{-wN} option specifies the hashtable size.
	The default for full state-space search is \co{-w24}.\footnote{
		As of Spin Version 6.4.6 and 6.4.8. In the online manual of
		Spin dated 10 July 2011, the default for exhaustive search
		mode is said to be \co{-w19}, which does not meet
		the actual behavior.}

	If you aren't sure whether your machine has enough memory,
	run \co{top} in one window and \co{./pan} in another.  Keep the
	focus on the \co{./pan} window so that you can quickly kill
	execution if need be.  As soon as CPU time drops much below
	100\,\%, kill \co{./pan}.  If you have removed focus from the
	window running \co{./pan}, you may wait a long time for the
	windowing system to grab enough memory to do anything for
	you.

	Another option to avoid memory exhaustion is the
	\co{-DMEMLIM=N} compiler flag. \co{-DMEMLIM=2000}
	would set the maximum of 2\,GB.

	Don't forget to capture the output, especially
	if you are working on a remote machine.

	If your model includes forward-progress checks, you will likely
	need to enable ``weak fairness'' via the \co{-f} command-line
	argument to \co{./pan}.
	If your forward-progress checks involve \co{accept} labels,
	you will also need the \co{-a} argument.
	% forward reference to model: formal.2009.02.19a in
	% /home/linux/git/userspace-rcu/formal-model.
\item	[\tco{spin -t -p qrcu.spin}]
	Given \co{trail} file output by a run that encountered an
	error, output the sequence of steps leading to that error.
	The \co{-g} flag will also include the values of changed
	global variables, and the  \co{-l} flag will also include
	the values of changed local variables.
\end{description}

\subsubsection{Promela Peculiarities}
\label{sec:formal:Promela Peculiarities}

Although all computer languages have underlying similarities,
Promela will provide some surprises to people used to coding in C,
C++, or Java.

\begin{enumerate}
\item	In C, ``\co{;}'' terminates statements.  In Promela it separates them.
	Fortunately, more recent versions of Spin have become
	much more forgiving of ``extra'' semicolons.
\item	Promela's looping construct, the \co{do} statement, takes
	conditions.
	This \co{do} statement closely resembles a looping if-then-else
	statement.
\item	In C's \co{switch} statement, if there is no matching case, the whole
	statement is skipped.  In Promela's equivalent, confusingly called
	\co{if}, if there is no matching guard expression, you get an error
	without a recognizable corresponding error message.
	So, if the error output indicates an innocent line of code,
	check to see if you left out a condition from an \co{if} or \co{do}
	statement.
\item	When creating stress tests in C, one usually races suspect operations
	against each other repeatedly.	In Promela, one instead sets up
	a single race, because Promela will search out all the possible
	outcomes from that single race.	Sometimes you do need to loop
	in Promela, for example, if multiple operations overlap, but
	doing so greatly increases the size of your state space.
\item	In C, the easiest thing to do is to maintain a loop counter to track
	progress and terminate the loop.  In Promela, loop counters
	must be avoided like the plague because they cause the state
	space to explode.  On the other hand, there is no penalty for
	infinite loops in Promela as long as none of the variables
	monotonically increase or decrease---Promela will figure out
	how many passes through the loop really matter, and automatically
	prune execution beyond that point.
\item	In C torture-test code, it is often wise to keep per-task control
	variables.  They are cheap to read, and greatly aid in debugging the
	test code.  In Promela, per-task control variables should be used
	only when there is no other alternative.  To see this, consider
	a 5-task verification with one bit each to indicate completion.
	This gives 32 states.  In contrast, a simple counter would have
	only six states, more than a five-fold reduction.  That factor
	of five might not seem like a problem, at least not until you
	are struggling with a verification program possessing more than
	150 million states consuming more than 10\,GB of memory!
\item	One of the most challenging things both in C torture-test code and
	in Promela is formulating good assertions.  Promela also allows
	\co{never} claims that act sort of like an assertion replicated
	between every line of code.
\item	Dividing and conquering is extremely helpful in Promela in keeping
	the state space under control.  Splitting a large model into two
	roughly equal halves will result in the state space of each
	half being roughly the square root of the whole.
	For example, a million-state combined model might reduce to a
	pair of thousand-state models.
	Not only will Promela handle the two smaller models much more
	quickly with much less memory, but the two smaller algorithms
	are easier for people to understand.
\end{enumerate}


\subsubsection{Promela Coding Tricks}
\label{sec:formal:Promela Coding Tricks}

Promela was designed to analyze protocols, so using it on parallel programs
is a bit abusive.
The following tricks can help you to abuse Promela safely:

\begin{enumerate}
\item	Memory reordering.  Suppose you have a pair of statements
	copying globals x and y to locals r1 and r2, where ordering
	matters (e.g., unprotected by locks), but where you have
	no memory barriers.  This can be modeled in Promela as follows:

\begin{VerbatimN}[samepage=true]
if
:: 1 -> r1 = x;
        r2 = y
:: 1 -> r2 = y;
        r1 = x
fi
\end{VerbatimN}

	The two branches of the \co{if} statement will be selected
	nondeterministically, since they both are available.
	Because the full state space is searched, \emph{both} choices
	will eventually be made in all cases.

	Of course, this trick will cause your state space to explode
	if used too heavily.
	In addition, it requires you to anticipate possible reorderings.

\item	State reduction.  If you have complex assertions, evaluate
	them under \co{atomic}.  After all, they are not part of the
	algorithm.  One example of a complex assertion (to be discussed
	in more detail later) is as shown in
	Listing~\ref{lst:formal:Complex Promela Assertion}.

	There is no reason to evaluate this assertion
	non-atomically, since it is not actually part of the algorithm.
	Because each statement contributes to state, we can reduce
	the number of useless states by enclosing it in an \co{atomic}
	block as shown in
	Listing~\ref{lst:formal:Atomic Block for Complex Promela Assertion}.

\item	Promela does not provide functions.
	You must instead use C preprocessor macros.
	However, you must use them carefully in order to avoid
	combinatorial explosion.
\end{enumerate}

\begin{listing}[tbp]
\begin{VerbatimL}
i = 0;
sum = 0;
do
:: i < N_QRCU_READERS ->
	sum = sum + (readerstart[i] == 1 &&
	             readerprogress[i] == 1);
	i++
:: i >= N_QRCU_READERS ->
	assert(sum == 0);
	break
od
\end{VerbatimL}
\caption{Complex Promela Assertion}
\label{lst:formal:Complex Promela Assertion}
\end{listing}

\begin{listing}[tbp]
\begin{VerbatimL}
atomic {
	i = 0;
	sum = 0;
	do
	:: i < N_QRCU_READERS ->
		sum = sum + (readerstart[i] == 1 &&
		             readerprogress[i] == 1);
		i++
	:: i >= N_QRCU_READERS ->
		assert(sum == 0);
		break
	od
}
\end{VerbatimL}
\caption{Atomic Block for Complex Promela Assertion}
\label{lst:formal:Atomic Block for Complex Promela Assertion}
\end{listing}

Now we are ready for more complex examples.

\subsection{Promela Example: Locking}
\label{sec:formal:Promela Example: Locking}
\NoIndentAfterThis

\begin{listing}[tbp]
\input{CodeSamples/formal/promela/lock@whole.fcv}
\caption{Promela Code for Spinlock}
\label{lst:formal:Promela Code for Spinlock}
\end{listing}

\begin{lineref}[ln:formal:promela:lock:whole]
Since locks are generally useful, \co{spin_lock()} and
\co{spin_unlock()}
macros are provided in \path{lock.h}, which may be included from
multiple Promela models, as shown in
Listing~\ref{lst:formal:Promela Code for Spinlock}.
The \co{spin_lock()} macro contains an infinite \co{do-od} loop
spanning lines~\lnref{dood:b}-\lnref{dood:e},
courtesy of the single guard expression of ``1'' on line~\lnref{one}.
The body of this loop is a single atomic block that contains
an \co{if-fi} statement.
The \co{if-fi} construct is similar to the \co{do-od} construct, except
that it takes a single pass rather than looping.
If the lock is not held on line~\lnref{notheld}, then
line~\lnref{acq} acquires it and
line~\lnref{break} breaks out of the enclosing \co{do-od} loop (and also exits
the atomic block).
On the other hand, if the lock is already held on line~\lnref{held},
we do nothing (\co{skip}), and fall out of the \co{if-fi} and the
atomic block so as to take another pass through the outer
loop, repeating until the lock is available.
\end{lineref}

The \co{spin_unlock()} macro simply marks the lock as no
longer held.

Note that memory barriers are not needed because Promela assumes
full ordering.
In any given Promela state, all processes agree on both the current
state and the order of state changes that caused us to arrive at
the current state.
This is analogous to the ``sequentially consistent'' memory model
used by a few computer systems (such as 1990s MIPS and PA-RISC).
As noted earlier, and as will be seen in a later example,
weak memory ordering must be explicitly coded.

\begin{listing}[tb]
\input{CodeSamples/formal/promela/lock@spin.fcv}
\caption{Promela Code to Test Spinlocks}
\label{lst:formal:Promela Code to Test Spinlocks}
\end{listing}

\begin{lineref}[ln:formal:promela:lock:spin]
These macros are tested by the Promela code shown in
Listing~\ref{lst:formal:Promela Code to Test Spinlocks}.
This code is similar to that used to test the increments,
with the number of locking processes defined by the \co{N_LOCKERS}
macro definition on line~\lnref{nlockers}.
The mutex itself is defined on line~\lnref{mutex},
an array to track the lock owner
on line~\lnref{array}, and line~\lnref{sum} is used by assertion
code to verify that only one process holds the lock.
\end{lineref}

\begin{lineref}[ln:formal:promela:lock:spin:locker]
The locker process is on lines~\lnref{b}-\lnref{e}, and simply loops forever
acquiring the lock on line~\lnref{lock}, claiming it on line~\lnref{claim},
unclaiming it on line~\lnref{unclaim}, and releasing it on line~\lnref{unlock}.
\end{lineref}

\begin{lineref}[ln:formal:promela:lock:spin:init]
The init block on lines~\lnref{b}-\lnref{e} initializes the current locker's
havelock array entry on line~\lnref{array}, starts the current locker on
line~\lnref{start}, and advances to the next locker on line~\lnref{next}.
Once all locker processes are spawned, the \co{do-od} loop
moves to line~\lnref{chkassert}, which checks the assertion.
Lines~\lnref{sum} and~\lnref{j} initialize the control variables,
lines~\lnref{atm:b}-\lnref{atm:e} atomically sum the havelock array entries,
line~\lnref{assert} is the assertion, and line~\lnref{break} exits the loop.
\end{lineref}

We can run this model by placing the two code fragments of
Listings~\ref{lst:formal:Promela Code for Spinlock}
and~\ref{lst:formal:Promela Code to Test Spinlocks} into
files named \path{lock.h} and \path{lock.spin}, respectively, and then running
the following commands:

\begin{VerbatimU}
spin -a lock.spin
cc -DSAFETY -o pan pan.c
./pan
\end{VerbatimU}

\begin{listing}[htbp]
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/lock.spin.lst}
\vspace*{-9pt}
\caption{Output for Spinlock Test}
\label{lst:formal:Output for Spinlock Test}
\end{listing}

The output will look something like that shown in
Listing~\ref{lst:formal:Output for Spinlock Test}.
As expected, this run has no assertion failures (``errors: 0'').

\QuickQuiz{}
	Why is there an unreached statement in
	locker?  After all, isn't this a \emph{full} state-space
	search?
\QuickQuizAnswer{
	The locker process is an infinite loop, so control
	never reaches the end of this process.
	However, since there are no monotonically increasing variables,
	Promela is able to model this infinite loop with a small
	number of states.
} \QuickQuizEnd

\QuickQuiz{}
	What are some Promela code-style issues with this example?
\QuickQuizAnswer{
	There are several:
	\begin{enumerate}
	\item	The declaration of \co{sum} should be moved to within
		the init block, since it is not used anywhere else.
	\item	The assertion code should be moved outside of the
		initialization loop.  The initialization loop can
		then be placed in an atomic block, greatly reducing
		the state space (by how much?).
	\item	The atomic block covering the assertion code should
		be extended to include the initialization of \co{sum}
		and \co{j}, and also to cover the assertion.
		This also reduces the state space (again, by how
		much?).
	\end{enumerate}
} \QuickQuizEnd


\subsection{Promela Example: QRCU}
\label{sec:formal:Promela Example: QRCU}

This final example demonstrates a real-world use of Promela on Oleg
Nesterov's
QRCU~\cite{OlegNesterov2006QRCU,OlegNesterov2006aQRCU},
but modified to speed up the \co{synchronize_qrcu()}
fastpath.

But first, what is QRCU?

QRCU is a variant of SRCU~\cite{PaulEMcKenney2006c}
that trades somewhat higher read overhead
(atomic increment and decrement on a global variable) for extremely
low grace-period latencies.
If there are no readers, the grace period will be detected in less
than a microsecond, compared to the multi-millisecond grace-period
latencies of most other RCU implementations.

\begin{enumerate}
\item	There is a \co{qrcu_struct} that defines a QRCU domain.
	Like SRCU (and unlike other variants of RCU) QRCU's action
	is not global, but instead focused on the specified
	\co{qrcu_struct}.
\item	There are \co{qrcu_read_lock()} and \co{qrcu_read_unlock()}
	primitives that delimit QRCU read-side critical sections.
	The corresponding \co{qrcu_struct} must be passed into
	these primitives, and the return value from \co{qrcu_read_lock()}
	must be passed to \co{qrcu_read_unlock()}.

	For example:

\begin{VerbatimU}
idx = qrcu_read_lock(&my_qrcu_struct);
/* read-side critical section. */
qrcu_read_unlock(&my_qrcu_struct, idx);
\end{VerbatimU}

\item	There is a \co{synchronize_qrcu()} primitive that blocks until
	all pre-existing QRCU read-side critical sections complete,
	but, like SRCU's \co{synchronize_srcu()}, QRCU's
	\co{synchronize_qrcu()} need wait only for those read-side
	critical sections that are using the same \co{qrcu_struct}.

	For example, \co{synchronize_qrcu(&your_qrcu_struct)}
	would \emph{not} need to wait on the earlier QRCU read-side
	critical section.
	In contrast, \co{synchronize_qrcu(&my_qrcu_struct)}
	\emph{would} need to wait, since it shares the same
	\co{qrcu_struct}.
\end{enumerate}

A Linux-kernel patch for QRCU has been
produced~\cite{PaulMcKenney2007QRCUpatch},
but is unlikely to ever be included in the Linux kernel.

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@gvar.fcv}
\caption{QRCU Global Variables}
\label{lst:formal:QRCU Global Variables}
\end{listing}

Returning to the Promela code for QRCU, the global variables are as shown in
Listing~\ref{lst:formal:QRCU Global Variables}.
This example uses locking, hence including \path{lock.h}.
Both the number of readers and writers can be varied using the
two \co{#define} statements, giving us not one but two ways to create
combinatorial explosion.
The \co{idx} variable controls which of the two elements of the \co{ctr}
array will be used by readers, and the \co{readerprogress} variable
allows an assertion to determine when all the readers are finished
(since a QRCU update cannot be permitted to complete until all
pre-existing readers have completed their QRCU read-side critical
sections).
The \co{readerprogress} array elements have values as follows,
indicating the state of the corresponding reader:

\begin{enumerate}[label={\arabic*}:,start=0,itemsep=0pt]
\item	not yet started.
\item	within QRCU read-side critical section.
\item	finished with QRCU read-side critical section.
\end{enumerate}

Finally, the \co{mutex} variable is used to serialize updaters' slowpaths.

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@reader.fcv}
\caption{QRCU Reader Process}
\label{lst:formal:QRCU Reader Process}
\end{listing}

\begin{lineref}[ln:formal:promela:qrcu:reader]
QRCU readers are modeled by the \co{qrcu_reader()} process shown in
Listing~\ref{lst:formal:QRCU Reader Process}.
A \co{do-od} loop spans lines~\lnref{do}-\lnref{od},
with a single guard of ``1''
on line~\lnref{one} that makes it an infinite loop.
Line~\lnref{curidx} captures the current value of the global index,
and lines~\lnref{atm:b}-\lnref{atm:e}
atomically increment it (and break from the infinite loop)
if its value was non-zero (\co{atomic_inc_not_zero()}).
Line~\lnref{cs:entry} marks entry into the RCU read-side critical section, and
line~\lnref{cs:exit} marks exit from this critical section,
both lines for the benefit of
the \co{assert()} statement that we shall encounter later.
Line~\lnref{atm:dec} atomically decrements the same counter that we incremented,
thereby exiting the RCU read-side critical section.
\end{lineref}

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@sum_unordered.fcv}
\caption{QRCU Unordered Summation}
\label{lst:formal:QRCU Unordered Summation}
\end{listing}

\begin{lineref}[ln:formal:promela:qrcu:sum_unordered]
The C-preprocessor macro shown in
Listing~\ref{lst:formal:QRCU Unordered Summation}
sums the pair of counters so as to emulate weak memory ordering.
Lines~\lnref{fetch:b}-\lnref{fetch:e} fetch one of the counters,
and line~\lnref{sum_other} fetches the other
of the pair and sums them.
The atomic block consists of a single \co{do-od} statement.
This \co{do-od} statement (spanning lines~\lnref{do}-\lnref{od}) is unusual in that
it contains two unconditional
branches with guards on lines~\lnref{g1} and~\lnref{g2}, which causes Promela to
non-deterministically choose one of the two (but again, the full
state-space search causes Promela to eventually make all possible
choices in each applicable situation).
The first branch fetches the zero-th counter and sets \co{i} to 1 (so
that line~\lnref{sum_other} will fetch the first counter), while the second
branch does the opposite, fetching the first counter and setting \co{i}
to 0 (so that line~\lnref{sum_other} will fetch the second counter).
\end{lineref}

\QuickQuiz{}
	Is there a more straightforward way to code the \co{do-od} statement?
\QuickQuizAnswer{
	Yes.
	Replace it with \co{if-fi} and remove the two \co{break} statements.
} \QuickQuizEnd

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@updater.fcv}
\caption{QRCU Updater Process}
\label{lst:formal:QRCU Updater Process}
\end{listing}

\begin{lineref}[ln:formal:promela:qrcu:updater]
With the \co{sum_unordered} macro in place, we can now proceed
to the update-side process shown in
Listing~\ref{lst:formal:QRCU Updater Process}.
The update-side process repeats indefinitely, with the corresponding
\co{do-od} loop ranging over lines~\lnref{do}-\lnref{od}.
Each pass through the loop first snapshots the global \co{readerprogress}
array into the local \co{readerstart} array on
lines~\lnref{atm1:b}-\lnref{atm1:e}.
This snapshot will be used for the assertion on line~\lnref{assert}.
Line~\lnref{sum_unord} invokes \co{sum_unordered}, and then
lines~\lnref{reinvoke:b}-\lnref{reinvoke:e}
re-invoke \co{sum_unordered} if the fastpath is potentially
usable.

Lines~\lnref{slow:b}-\lnref{slow:e} execute the slowpath code if need be, with
lines~\lnref{acq} and~\lnref{rel} acquiring and releasing the update-side lock,
lines~\lnref{flip_idx:b}-\lnref{flip_idx:e} flipping the index, and
lines~\lnref{wait:b}-\lnref{wait:e} waiting for
all pre-existing readers to complete.

Lines~\lnref{atm2:b}-\lnref{atm2:e} then compare the current values
in the \co{readerprogress}
array to those collected in the \co{readerstart} array,
forcing an assertion failure should any readers that started before
this update still be in progress.
\end{lineref}

\QuickQuiz{}
	\begin{lineref}[ln:formal:promela:qrcu:updater]
	Why are there atomic blocks at lines~\lnref{atm1:b}-\lnref{atm1:e}
	and lines~\lnref{atm2:b}-\lnref{atm2:e}, when the operations
	within those atomic
	blocks have no atomic implementation on any current
	production microprocessor?
	\end{lineref}
\QuickQuizAnswer{
	Because those operations are for the benefit of the
	assertion only.  They are not part of the algorithm itself.
	There is therefore no harm in marking them atomic, and
	so marking them greatly reduces the state space that must
	be searched by the Promela model.
} \QuickQuizEnd

\QuickQuiz{}
	\begin{lineref}[ln:formal:promela:qrcu:updater]
	Is the re-summing of the counters on
        lines~\lnref{reinvoke:b}-\lnref{reinvoke:e}
	\emph{really} necessary?
        \end{lineref}
\QuickQuizAnswer{
	Yes.  To see this, delete these lines and run the model.

	Alternatively, consider the following sequence of steps:

	\begin{enumerate}
	\item	One process is within its RCU read-side critical
		section, so that the value of \co{ctr[0]} is zero and
		the value of \co{ctr[1]} is two.
	\item	An updater starts executing, and sees that the sum of
		the counters is two so that the fastpath cannot be
		executed.  It therefore acquires the lock.
	\item	A second updater starts executing, and fetches the value
		of \co{ctr[0]}, which is zero.
	\item	The first updater adds one to \co{ctr[0]}, flips
		the index (which now becomes zero), then subtracts
		one from \co{ctr[1]} (which now becomes one).
	\item	The second updater fetches the value of \co{ctr[1]},
		which is now one.
	\item	The second updater now incorrectly concludes that it
		is safe to proceed on the fastpath, despite the fact
		that the original reader has not yet completed.
	\end{enumerate}
} \QuickQuizEnd

\begin{listing}[htbp]
\input{CodeSamples/formal/promela/qrcu@init.fcv}
\caption{QRCU Initialization Process}
\label{lst:formal:QRCU Initialization Process}
\end{listing}

\begin{lineref}[ln:formal:promela:qrcu:init]
All that remains is the initialization block shown in
Listing~\ref{lst:formal:QRCU Initialization Process}.
This block simply initializes the counter pair on
lines~\lnref{i_ctr:b}-\lnref{i_ctr:e},
spawns the reader processes on
lines~\lnref{spn_r:b}-\lnref{spn_r:e}, and spawns the updater
processes on lines~\lnref{spn_u:b}-\lnref{spn_u:e}.
This is all done within an atomic block to reduce state space.
\end{lineref}

\subsubsection{Running the QRCU Example}
\label{sec:formal:Running the QRCU Example}

To run the QRCU example, combine the code fragments in the previous
section into a single file named \path{qrcu.spin}, and place the definitions
for \co{spin_lock()} and \co{spin_unlock()} into a file named
\path{lock.h}.
Then use the following commands to build and run the QRCU model:

\begin{VerbatimU}
spin -a qrcu.spin
cc -DSAFETY [-DCOLLAPSE] -o pan pan.c
./pan [-mN]
\end{VerbatimU}

\begin{table}
\centering
\begin{threeparttable}
\rowcolors{1}{}{lightgray}
\renewcommand*{\arraystretch}{1.2}
\footnotesize
\begin{tabular}{S[table-format = 1.0]S[table-format = 1.0]S[table-format = 9.0]
		S[table-format = 6.0]S[table-format = 5.1]}
	\toprule
	\multicolumn{1}{r}{updaters} &
	    \multicolumn{1}{r}{readers} &
		\multicolumn{1}{r}{\# states} &
		    \multicolumn{1}{r}{depth} &
			\multicolumn{1}{r}{memory (MB)\tnote{a}} \\
	\midrule
	1 & 1 &         376 &      95 &    128.7 \\
	1 & 2 &       6 177 &     218 &    128.9 \\
	1 & 3 &      99 728 &     385 &    132.6 \\
	2 & 1 &      29 399 &     859 &    129.8 \\
	2 & 2 &   1 071 181 &   2 352 &    169.6 \\
	2 & 3 &  33 866 736 &  12 857 &  1 540.8 \\
	3 & 1 &   2 749 453 &  53 809 &    236.6 \\
	3 & 2 & 186 202 860 & 328 014 & 10 483.7 \\
	\bottomrule
\end{tabular}
\begin{tablenotes}
	\item [a] Obtained with the compiler flag \co{-DCOLLAPSE}
		specified.
\end{tablenotes}
\end{threeparttable}
\caption{Memory Usage of QRCU Model}
\label{tab:advsync:Memory Usage of QRCU Model}
\end{table}

The output shows that this model passes all of the cases shown in
Table~\ref{tab:advsync:Memory Usage of QRCU Model}.
It would be nice to run three readers and three
updaters, however, simple extrapolation indicates that this will
require about half a terabyte of memory.
What to do?

It turns out that \co{./pan} gives advice when it runs out of memory,
for example, when attempting to run three readers and three updaters:

\begin{VerbatimU}
hint: to reduce memory, recompile with
  -DCOLLAPSE # good, fast compression, or
  -DMA=96   # better/slower compression, or
  -DHC # hash-compaction, approximation
  -DBITSTATE # supertrace, approximation
\end{VerbatimU}

Let's try the suggested compiler flag \co{-DMA=N},
which generates code for aggressive compression of the
state space at the cost of greatly increased search overhead.
The required commands are as follows:

\begin{VerbatimU}
spin -a qrcu.spin
cc -DSAFETY -DMA=96 -O2 -o pan pan.c
./pan -m20000000
\end{VerbatimU}

Here, the depth limit of 20,000,000 is an order of magnitude
larger than the expected depth deduced from simple extrapolation.
Although this increases up-front memory usage, it avoids wasting
a long run due to incomplete search resulting from a too-tight
depth limit.
This run took a little more than 3~days on a \Power{9} server.
The result is shown in
Listing~\ref{lst:formal:spinhint:3 Readers 3 Updaters QRCU Spin Output with -DMA=96}.
This Spin run completed successfully with a total memory
usage of only 6.5\,GB, which is almost two orders of magnitude
lower than the \co{-DCOLLAPSE} usage of about half a terabyte.

\begin{listing}
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/qrcu.spin.33ma.lst}
\vspace*{-9pt}
\caption{3 Readers 3 Updaters QRCU Spin Output with \co{-DMA=96}}
\label{lst:formal:spinhint:3 Readers 3 Updaters QRCU Spin Output with -DMA=96}
\end{listing}

\QuickQuiz{}
	A compression rate of 0.48\,\% corresponds to a 200-to-1 decrease
	in memory occupied by the states!
	Is the state-space search \emph{really} exhaustive???
\QuickQuizAnswer{
	According to Spin's documentation, yes, it is.

\begin{listing}
\VerbatimInput[numbers=none,fontsize=\scriptsize]{CodeSamples/formal/promela/qrcu.spin.col-ma.diff.lst}
\vspace*{-9pt}
\caption{Spin Output Diff of \co{-DCOLLAPSE} and \co{-DMA=88}}
\label{lst:formal:promela:Spin Output Diff of -DCOLLAPSE and -DMA=88}
\end{listing}

	As an indirect evidence, let's compare the results of
	runs with \co{-DCOLLAPSE} and with \co{-DMA=88}
	(two readers and three updaters).
	The diff of outputs from those runs is shown in
	Listing~\ref{lst:formal:promela:Spin Output Diff of -DCOLLAPSE and -DMA=88}.
	As you can see, they agree on the numbers of states
	(stored and matched).
} \QuickQuizEnd

\begin{table*}[tbp]
\rowcolors{6}{}{lightgray}
\renewcommand*{\arraystretch}{1.2}
\footnotesize
\centering
\OneColumnHSpace{-0.7in}%
\begin{tabular}{S[table-format = 1.0]S[table-format = 1.0]S[table-format = 9.0]
		S[table-format = 9.0]S[table-format = 2.0]S[table-format = 5.2]
		S[table-format = 4.2]S[table-format = 2.0]S[table-format = 4.2]
		S[table-format = 6.2]}
	\toprule
	\multicolumn{4}{r}{} & \multicolumn{3}{c}{\tco{-DCOLLAPSE}} &
					\multicolumn{3}{c}{\tco{-DMA=N}} \\
	\cmidrule(l){5-7} \cmidrule(l){8-10}
	\multicolumn{1}{r}{updaters} &
	    \multicolumn{1}{r}{readers} &
		\multicolumn{1}{r}{\# states} &
		    \multicolumn{1}{r}{depth reached} &
			\multicolumn{1}{r}{\tco{-wN}} &
			    \multicolumn{1}{r}{memory (MB)} &
				\multicolumn{1}{r}{runtime (s)} &
				    \multicolumn{1}{r}{\tco{N}} &
					\multicolumn{1}{r}{memory (MB)} &
					    \multicolumn{1}{r}{runtime (s)} \\
	\cmidrule{1-4} \cmidrule(l){5-7} \cmidrule(l){8-10}
	1 & 1 &           376 &         95 & 12 &     0.10 & 0.00 &
		40 &    0.29 &      0.00 \\
	1 & 2 &         6 177 &        218 & 12 &     0.39 & 0.01 &
		47 &    0.59 &      0.02 \\
	1 & 3 &        99 728 &        385 & 16 &     4.60 & 0.14 &
		54 &    3.04 &      0.45 \\
        2 & 1 &        29 399 &        859 & 16 &     2.30 & 0.03 &
		55 &    0.70 &      0.13 \\
        2 & 2 &     1 071 181 &      2 352 & 20 &    49.24 & 1.45 &
		62 &    7.77 &      5.76 \\
        2 & 3 &    33 866 736 &     12 857 & 24 & 1 540.70 & 62.5 &
		69 &  111.66 &    326    \\
        3 & 1 &     2 749 453 &     53 809 & 21 &   125.25 & 4.01 &
		70 &   11.41 &     19.5  \\
        3 & 2 &   186 202 860 &    328 014 & 28 & 10 482.51 & 390 &
		77 &  222.26 &   2560    \\
	3 & 3 & 9 664 707 100 &  2 055 621 &    &          &      &
		84 & 5557.02 & 266000    \\
	\bottomrule
\end{tabular}
\caption{QRCU Spin Result Summary}
\label{tab:formal:promela:QRCU Spin Result Summary}
\end{table*}

For reference, Table~\ref{tab:formal:promela:QRCU Spin Result Summary}
summarizes the Spin results with \co{-DCOLLAPSE} and \co{-DMA=N}
compiler flags.
The memory usage is obtained with minimal sufficient
search depths and \co{-DMA=N} parameters shown in the table.
Hashtable sizes for \co{-DCOLLAPSE} runs are tweaked by
the \co{-wN} option of \co{./pan} to avoid using too much
memory hashing small state spaces.
Hence the memory usage is smaller than what is shown in
Table~\ref{tab:advsync:Memory Usage of QRCU Model}, where the
hashtable size starts from the default of \co{-w24}.
The runtime is from a \Power{9} server, which shows that \co{-DMA=N}
suffers up to about an order of magnitude higher CPU overhead
than does \co{-DCOLLAPSE}, but on the other hand reduces memory overhead
by well over an order of magnitude.

So far so good.
But adding a few more updaters or readers would exhaust memory, even
with \co{-DMA=N}.\footnote{
	Alternatively, the CPU consumption would become excessive.}
So what to do?
Here are some possible approaches:

\begin{enumerate}
\item	See whether a smaller number of readers and updaters suffice
	to prove the general case.
\item	Manually construct a proof of correctness.
\item	Use a more capable tool.
\item	Divide and conquer.
\end{enumerate}

The following sections discuss each of these approaches.

\subsubsection{How Many Readers and Updaters Are Really Needed?}
\label{sec:formal:How Many Readers and Updaters Are Really Needed?}

One approach is to look carefully at the Promela code for
\co{qrcu_updater()} and notice that the only global state
change is happening under the lock.
Therefore, only one updater at a time can possibly be modifying
state visible to either readers or other updaters.
This means that any sequences of state changes can be carried
out serially by a single updater due to the fact that Promela does a full
state-space search.
Therefore, at most two updaters are required: one to change state
and a second to become confused.

The situation with the readers is less clear-cut, as each reader
does only a single read-side critical section then terminates.
It is possible to argue that the useful number of readers is limited,
due to the fact that the fastpath must see at most a zero and a one
in the counters.
This is a fruitful avenue of investigation, in fact, it leads to
the full proof of correctness described in the next section.

\subsubsection{Alternative Approach: Proof of Correctness}
\label{sec:formal:Alternative Approach: Proof of Correctness}

An informal proof~\cite{PaulMcKenney2007QRCUpatch}
follows:

\begin{enumerate}
\item	For \co{synchronize_qrcu()} to exit too early, then
	by definition there must have been at least one reader
	present during \co{synchronize_qrcu()}'s full
	execution.
\item	The counter corresponding to this reader will have been
	at least 1 during this time interval.
\item	The \co{synchronize_qrcu()} code forces at least one
	of the counters to be at least 1 at all times.
\item	Therefore, at any given point in time, either one of the
	counters will be at least 2, or both of the counters will
	be at least one.
\item	However, the \co{synchronize_qrcu()} fastpath code
	can read only one of the counters at a given time.
	It is therefore possible for the fastpath code to fetch
	the first counter while zero, but to race with a counter
	flip so that the second counter is seen as one.
\item	There can be at most one reader persisting through such
	a race condition, as otherwise the sum would be two or
	greater, which would cause the updater to take the slowpath.
\item	But if the race occurs on the fastpath's first read of the
	counters, and then again on its second read, there have
	to have been two counter flips.
\item	Because a given updater flips the counter only once, and
	because the update-side lock prevents a pair of updaters
	from concurrently flipping the counters, the only way that
	the fastpath code can race with a flip twice is if the
	first updater completes.
\item	But the first updater will not complete until after all
	pre-existing readers have completed.
\item	Therefore, if the fastpath races with a counter flip
	twice in succession, all pre-existing readers must have
	completed, so that it is safe to take the fastpath.
\end{enumerate}

Of course, not all parallel algorithms have such simple proofs.
In such cases, it may be necessary to enlist more capable tools.

\subsubsection{Alternative Approach: More Capable Tools}
\label{sec:formal:Alternative Approach: More Capable Tools}

Although Promela and Spin are quite useful,
much more capable tools are available, particularly for verifying
hardware.
This means that if it is possible to translate your algorithm
to the hardware-design VHDL language, as it often will be for
low-level parallel algorithms, then it is possible to apply these
tools to your code (for example, this was done for the first
realtime RCU algorithm).
However, such tools can be quite expensive.

Although the advent of commodity multiprocessing
might eventually result in powerful free-software model-checkers
featuring fancy state-space-reduction capabilities,
this does not help much in the here and now.

As an aside, there are Spin features that support approximate searches
that require fixed amounts of memory, however, I have never been able
to bring myself to trust approximations when verifying parallel
algorithms.

Another approach might be to divide and conquer.

\subsubsection{Alternative Approach: Divide and Conquer}
\label{sec:formal:Alternative Approach: Divide and Conquer}

It is often possible to break down a larger parallel algorithm into
smaller pieces, which can then be proven separately.
For example, a 10-billion-state model might be broken into a pair
of 100,000-state models.
Taking this approach not only makes it easier for tools such as
Promela to verify your algorithms, it can also make your algorithms
easier to understand.

\subsubsection{Is QRCU Really Correct?}
\label{sec:formal:Is QRCU Really Correct?}

Is QRCU really correct?
We have a Promela-based mechanical proof and a by-hand proof that both
say that it is.
However, a recent paper by Alglave et al.~\cite{JadeAlglave2013-cav}
says otherwise (see Section~5.1 of the paper at the bottom of page~12).
Which is it?

It turns out that both are correct!
When QRCU was added to a suite of formal-verification benchmarks,
its memory barriers were omitted, thus resulting in a buggy version
of QRCU.
So the real news here is that a number of formal-verification tools
incorrectly proved this buggy QRCU correct.
And this is why formal-verification tools themselves should be tested
using bug-injected versions of the code being verified.
If a given tool cannot find the injected bugs, then that tool is
clearly untrustworthy.

\QuickQuiz{}
	But different formal-verification tools are often designed to
	locate particular classes of bugs.
	For example, very few formal-verification tools will find
	an error in the specification.
	So isn't this ``clearly untrustworthy'' judgment a bit harsh?
\QuickQuizAnswer{
	It is certainly true that many formal-verification tools are
	specialized in some way.
	For example, Promela does not handle realistic memory models
	(though they can be programmed into
	Promela~\cite{Desnoyers:2013:MSM:2506164.2506174}),
	CBMC~\cite{EdmundClarke2004CBMC} does not detect probabilistic
	hangs and deadlocks, and
	Nidhugg~\cite{CarlLeonardsson2014Nidhugg} does not detect
	bugs involving data nondeterminism.
	But this means that that these tools cannot be trusted to find
	bugs that they are not designed to locate.

	And therefore people creating formal-verification tools should
	``tell the truth on the label'', clearly calling out what
	classes of bugs their tools can and cannot detect.
	Otherwise, the first time a practitioner finds a tool
	failing to detect a bug, that practitioner is likely to
	make extremely harsh and extremely public denunciations
	of that tool.
	Yes, yes, there is something to be said for putting your
	best foot forward, but putting it too far forward without
	appropriate disclaimers can easily trigger a land mine of
	negative reaction that your tool might or might not be able
	to recover from.

	You have been warned!
} \QuickQuizEnd

Therefore, if you do intend to use QRCU, please take care.
Its proofs of correctness might or might not themselves be correct.
Which is one reason why formal verification is unlikely to
completely replace testing, as Donald Knuth pointed out so long ago.

\QuickQuiz{}
	Given that we have two independent proofs of correctness for
	the QRCU algorithm described herein, and given that the
	proof of incorrectness covers what is known to be a different
	algorithm, why is there any room for doubt?
\QuickQuizAnswer{
	There is always room for doubt.
	In this case, it is important to keep in mind that the two proofs
	of correctness preceded the formalization of real-world memory
	models, raising the possibility that these two proofs are based
	on incorrect memory-ordering assumptions.
	Furthermore, since both proofs were constructed by the same person,
	it is quite possible that they contain a common error.
	Again, there is always room for doubt.
} \QuickQuizEnd
